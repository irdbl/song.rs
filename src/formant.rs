//! 2-channel orthogonal vocal modem: vowel (formants) + pitch.
//!
//! Each symbol encodes 4 bits via two independent channels:
//! - Vowel (3 bits): F1/F2 formant frequencies (8 vowels)
//! - Pitch (1 bit): F0 frequency (200 Hz low / 280 Hz high)

use std::f64::consts::PI;

use crate::protocol::*;

/// Vowel parameters for one symbol.
#[derive(Debug, Clone, Copy)]
pub struct VowelParams {
    pub f1: f64,
    pub f2: f64,
}

/// Pitch class (F0 frequency).
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum PitchClass {
    Low = 0,
    High = 1,
}

impl PitchClass {
    pub fn from_index(i: usize) -> Self {
        match i {
            0 => Self::Low,
            1 => Self::High,
            _ => panic!("invalid pitch index: {i}"),
        }
    }

    /// Return the F0 frequency for this pitch class.
    pub fn f0(self) -> f64 {
        match self {
            Self::Low => F0_LOW,
            Self::High => F0_HIGH,
        }
    }
}

/// The 8-vowel alphabet, designed for dual-F0 (210/270 Hz) discrimination.
///
/// Optimized vowel alphabet (generated by examples/optimize_vowels.rs).
///
/// Maximizes min pairwise classification distance across both F0 values.
/// Each vowel snaps to a unique (F1,F2) harmonic pair at both F0_LOW and F0_HIGH.
/// F1 uses 4 groups across 3 low harmonics × 2 high harmonics.
/// F2 spread across the full 850–2500 Hz band.
/// All F1 values ≥ 480 Hz to survive 300 Hz phone highpass.
pub const VOWELS: [VowelParams; NUM_VOWELS] = [
    VowelParams { f1: 480.0, f2: 1065.0 }, // 0 — mid-F1
    VowelParams { f1: 480.0, f2: 1890.0 }, // 1 — mid-F1
    VowelParams { f1: 480.0, f2: 2370.0 }, // 2 — mid-F1
    VowelParams { f1: 585.0, f2: 1410.0 }, // 3 — high-F1
    VowelParams { f1: 720.0, f2: 1065.0 }, // 4 — high-F1
    VowelParams { f1: 720.0, f2: 1890.0 }, // 5 — high-F1
    VowelParams { f1: 825.0, f2: 1410.0 }, // 6 — high-F1
    VowelParams { f1: 825.0, f2: 2370.0 }, // 7 — high-F1
];

/// Start preamble: vowel0@low, vowel7@low, repeat.
/// Vowels 0 and 7 have maximum F1+F2 separation (distance 7.38).
/// Symbol index = vowel*2 + pitch.
pub const PREAMBLE_START: [usize; PREAMBLE_LEN] = [0, 14, 0, 14];

/// End preamble: vowel7@low, vowel0@low, repeat.
pub const PREAMBLE_END: [usize; PREAMBLE_LEN] = [14, 0, 14, 0];

// --- Symbol mapping ---

/// Decompose a 4-bit symbol index into (vowel, pitch) components.
///
/// Bit layout: `[V2 V1 V0 P]`
/// - vowel = bits 3..1 (index >> 1)
/// - pitch = bit 0 (index & 1)
#[inline]
pub fn symbol_to_params(idx: usize) -> (usize, PitchClass) {
    debug_assert!(idx < NUM_SYMBOLS);
    let vowel = (idx >> 1) & 0x7;
    let pitch = idx & 0x1;
    (vowel, PitchClass::from_index(pitch))
}

/// Compose a 4-bit symbol index from (vowel, pitch) components.
#[inline]
pub fn params_to_symbol(vowel: usize, pitch: usize) -> usize {
    debug_assert!(vowel < NUM_VOWELS);
    debug_assert!(pitch < NUM_PITCHES);
    (vowel << 1) | pitch
}

/// Extract vowel index from composite symbol index.
#[inline]
pub fn symbol_vowel(idx: usize) -> usize {
    (idx >> 1) & 0x7
}

// --- Synthesis ---

/// Compute harmonic amplitudes shaped by F1/F2 Gaussian formant envelopes.
///
/// Returns amplitudes for harmonics H1..H16 at the given F0.
pub fn harmonic_amplitudes(f1: f64, f2: f64, f0: f64) -> [f64; NUM_HARMONICS] {
    let mut amps = [0.0f64; NUM_HARMONICS];
    for h in 0..NUM_HARMONICS {
        let freq = f0 * (h + 1) as f64;
        let g1 = (-(freq - f1).powi(2) / (2.0 * BW1 * BW1)).exp();
        let g2 = (-(freq - f2).powi(2) / (2.0 * BW2 * BW2)).exp();
        amps[h] = g1 + g2;
    }
    let max = amps.iter().cloned().fold(0.0f64, f64::max);
    if max > 0.0 {
        for a in &mut amps {
            *a /= max;
        }
    }
    amps
}

/// Synthesize one symbol's audio: SAMPLES_PER_SYMBOL of voiced audio.
///
/// Returns exactly SAMPLES_PER_SYMBOL f64 samples (no guard silence).
/// Decomposes symbol index into vowel/pitch, synthesizes harmonics
/// shaped by formants at the pitch-determined F0, applies 5ms fade in/out.
pub fn synthesize_symbol(symbol_idx: usize, volume: f64) -> Vec<f64> {
    let (vowel_idx, pitch_class) = symbol_to_params(symbol_idx);
    let vowel = &VOWELS[vowel_idx];
    let f0 = pitch_class.f0();
    let amps = harmonic_amplitudes(vowel.f1, vowel.f2, f0);

    let fade_samples = (SAMPLE_RATE * 0.005) as usize; // 5ms = 240 samples
    let mut out = vec![0.0f64; SAMPLES_PER_SYMBOL];

    for i in 0..SAMPLES_PER_SYMBOL {
        let t_abs = i as f64 / SAMPLE_RATE;

        // Harmonic synthesis
        let mut sample = 0.0f64;
        for h in 0..NUM_HARMONICS {
            let freq = f0 * (h + 1) as f64;
            sample += amps[h] * (2.0 * PI * freq * t_abs).sin();
        }

        // Apply fade in/out
        let fade = if i < fade_samples {
            i as f64 / fade_samples as f64
        } else if i >= SAMPLES_PER_SYMBOL - fade_samples {
            (SAMPLES_PER_SYMBOL - 1 - i) as f64 / fade_samples as f64
        } else {
            1.0
        };

        out[i] = sample * volume * fade;
    }

    out
}

// --- Detection ---

/// Detect F0 from a power spectrum by testing candidate F0 values.
///
/// Scores each candidate by summing spectral power at expected harmonic bins.
/// Returns the best-fit F0.
pub fn detect_f0(spectrum: &[f32]) -> f64 {
    let mut best_f0 = F0_LOW;
    let mut best_score = 0.0f64;

    for &f0 in &F0_CANDIDATES {
        let mut score = 0.0f64;
        for h in 1..=NUM_HARMONICS {
            let freq = f0 * h as f64;
            let bin = (freq / HZ_PER_BIN).round() as usize;
            if bin >= spectrum.len() {
                break;
            }
            // Sum power in ±2 bin window
            for offset in 0..=2usize {
                if offset == 0 {
                    score += spectrum[bin] as f64;
                } else {
                    if bin >= offset {
                        score += spectrum[bin - offset] as f64 * 0.5;
                    }
                    if bin + offset < spectrum.len() {
                        score += spectrum[bin + offset] as f64 * 0.5;
                    }
                }
            }
        }
        if score > best_score {
            best_score = score;
            best_f0 = f0;
        }
    }

    best_f0
}

/// Detect formant frequencies from a power spectrum using a detected F0.
///
/// Finds peak harmonic power in F1 band (200-800 Hz) and F2 band (800-2500 Hz)
/// using the detected F0's harmonic positions, with ±2 bin window.
pub fn detect_formants(spectrum: &[f32], f0: f64) -> (f64, f64) {
    let mut best_f1_power = 0.0f64;
    let mut best_f1_freq = 300.0;
    let mut best_f2_power = 0.0f64;
    let mut best_f2_freq = 1500.0;

    for h in 1..=NUM_HARMONICS {
        let freq = f0 * h as f64;
        let bin = (freq / HZ_PER_BIN).round() as usize;
        if bin >= spectrum.len() {
            break;
        }

        let mut power = 0.0f64;
        for offset in 0..=2usize {
            if offset == 0 {
                power += spectrum[bin] as f64;
            } else {
                if bin >= offset && bin - offset < spectrum.len() {
                    power += spectrum[bin - offset] as f64;
                }
                if bin + offset < spectrum.len() {
                    power += spectrum[bin + offset] as f64;
                }
            }
        }

        if freq >= F1_LO && freq <= F1_HI && power > best_f1_power {
            best_f1_power = power;
            best_f1_freq = freq;
        }
        if freq >= F2_LO && freq <= F2_HI && power > best_f2_power {
            best_f2_power = power;
            best_f2_freq = freq;
        }
    }

    (best_f1_freq, best_f2_freq)
}

/// Classify detected (f1, f2) to the nearest vowel.
///
/// Uses weighted Euclidean distance. Returns (vowel_index, margin_confidence).
pub fn classify_vowel(f1: f64, f2: f64) -> (usize, f64) {
    let mut best_idx = 0;
    let mut best_dist = f64::MAX;
    let mut second_dist = f64::MAX;

    for (i, v) in VOWELS.iter().enumerate() {
        let d1 = (f1 - v.f1) / 100.0;
        let d2 = (f2 - v.f2) / 200.0;
        let dist = (d1 * d1 + d2 * d2).sqrt();

        if dist < best_dist {
            second_dist = best_dist;
            best_dist = dist;
            best_idx = i;
        } else if dist < second_dist {
            second_dist = dist;
        }
    }

    let confidence = if best_dist > 0.0 {
        (second_dist - best_dist) / best_dist
    } else {
        second_dist
    };

    (best_idx, confidence)
}

/// Detect pitch class from detected F0.
pub fn detect_pitch(f0: f64) -> (PitchClass, f64) {
    let margin = (f0 - PITCH_THRESHOLD).abs();
    if f0 < PITCH_THRESHOLD {
        (PitchClass::Low, margin)
    } else {
        (PitchClass::High, margin)
    }
}

/// Classify a full symbol from a power spectrum.
///
/// Orchestrates both channels: vowel (formant detection) and pitch (F0 frequency).
/// Returns (composite_symbol_index, composite_confidence).
pub fn classify_symbol(spectrum: &[f32]) -> (usize, f64) {
    let f0 = detect_f0(spectrum);
    let (f1, f2) = detect_formants(spectrum, f0);
    let (vowel_idx, vowel_conf) = classify_vowel(f1, f2);
    let (pitch_class, pitch_conf) = detect_pitch(f0);

    let symbol_idx = params_to_symbol(
        vowel_idx,
        pitch_class as usize,
    );

    // Normalize confidences into a comparable 0..1 range before combining.
    let vowel_conf = normalize_confidence(vowel_conf);
    let pitch_conf = normalize_pitch_confidence(pitch_conf);

    // Composite confidence weighted by channel importance.
    let confidence = vowel_conf * 0.7 + pitch_conf * 0.3;

    (symbol_idx, confidence)
}

/// Map raw vowel confidence (0..∞) into 0..1 for stable mixing.
#[inline]
fn normalize_confidence(raw: f64) -> f64 {
    let raw = raw.max(0.0);
    raw / (raw + 1.0)
}

/// Map pitch margin (Hz) into 0..1 based on candidate extremes.
#[inline]
fn normalize_pitch_confidence(margin_hz: f64) -> f64 {
    // Candidates span 200..280 Hz with threshold at 240 => max margin = 40 Hz.
    const MAX_MARGIN_HZ: f64 = 40.0;
    (margin_hz / MAX_MARGIN_HZ).clamp(0.0, 1.0)
}

// --- 4-bit packing ---

/// Pack bytes into 4-bit symbol indices.
///
/// Converts a byte slice into a bitstream, then extracts 4-bit chunks.
/// Pads with zeros at the end if not aligned.
pub fn bytes_to_symbols(bytes: &[u8]) -> Vec<usize> {
    let total_bits = bytes.len() * 8;
    let n_symbols = (total_bits + BITS_PER_SYMBOL - 1) / BITS_PER_SYMBOL;
    let mut symbols = Vec::with_capacity(n_symbols);

    let mut bit_pos = 0;
    for _ in 0..n_symbols {
        let mut val = 0usize;
        for b in 0..BITS_PER_SYMBOL {
            let byte_idx = (bit_pos + b) / 8;
            let bit_idx = 7 - ((bit_pos + b) % 8); // MSB first
            if byte_idx < bytes.len() {
                val |= (((bytes[byte_idx] >> bit_idx) & 1) as usize) << (BITS_PER_SYMBOL - 1 - b);
            }
        }
        symbols.push(val);
        bit_pos += BITS_PER_SYMBOL;
    }

    symbols
}

/// Unpack 4-bit symbol indices back into bytes.
///
/// Extracts the bitstream from symbol indices and packs into bytes.
/// `num_bytes` specifies how many output bytes to produce.
pub fn symbols_to_bytes(symbols: &[usize], num_bytes: usize) -> Vec<u8> {
    let mut bytes = vec![0u8; num_bytes];

    let mut bit_pos = 0;
    for &sym in symbols {
        for b in 0..BITS_PER_SYMBOL {
            let byte_idx = (bit_pos + b) / 8;
            let bit_idx = 7 - ((bit_pos + b) % 8);
            if byte_idx < num_bytes {
                let bit_val = (sym >> (BITS_PER_SYMBOL - 1 - b)) & 1;
                bytes[byte_idx] |= (bit_val as u8) << bit_idx;
            }
        }
        bit_pos += BITS_PER_SYMBOL;
    }

    bytes
}

/// Compute number of symbols needed to encode n_bytes.
pub fn symbols_for_bytes(n_bytes: usize) -> usize {
    (n_bytes * 8 + BITS_PER_SYMBOL - 1) / BITS_PER_SYMBOL
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_symbol_decompose_compose_roundtrip() {
        for idx in 0..NUM_SYMBOLS {
            let (v, p) = symbol_to_params(idx);
            let back = params_to_symbol(v, p as usize);
            assert_eq!(idx, back, "symbol {idx} decompose/compose mismatch");
        }
    }

    #[test]
    fn test_symbol_vowel_extraction() {
        for idx in 0..NUM_SYMBOLS {
            let (v, _) = symbol_to_params(idx);
            assert_eq!(v, symbol_vowel(idx));
        }
    }

    #[test]
    fn test_bit_packing_roundtrip() {
        for len in 1..=20 {
            let bytes: Vec<u8> = (0..len).map(|i| ((i * 37 + 13) % 256) as u8).collect();
            let symbols = bytes_to_symbols(&bytes);
            let back = symbols_to_bytes(&symbols, len);
            assert_eq!(bytes, back, "packing roundtrip failed for len {len}");
        }
    }

    #[test]
    fn test_bit_packing_all_byte_values() {
        for b in 0..=255u8 {
            let bytes = vec![b];
            let symbols = bytes_to_symbols(&bytes);
            let back = symbols_to_bytes(&symbols, 1);
            assert_eq!(bytes, back, "packing roundtrip failed for byte {b:#04x}");
        }
    }

    #[test]
    fn test_bit_packing_known_values() {
        // All zeros
        let syms = bytes_to_symbols(&[0, 0, 0]);
        assert!(syms.iter().all(|&s| s == 0));

        // All ones: 0xFF, 0xFF, 0xFF = 24 bits = six 4-bit symbols of 15
        let syms = bytes_to_symbols(&[0xFF, 0xFF, 0xFF]);
        assert_eq!(syms.len(), 6);
        assert!(syms.iter().all(|&s| s == 15));
    }

    #[test]
    fn test_harmonic_amplitudes_shape() {
        // Vowel 1: f1=605, f2=2300 at F0_LOW=210 Hz
        // H3=630 is near F1=605, should be strong
        let amps = harmonic_amplitudes(605.0, 2300.0, F0_LOW);
        assert!(amps[2] > 0.5, "H3 should be strong near F1=605: {}", amps[2]);
    }

    #[test]
    fn test_classify_known_vowels() {
        for (i, v) in VOWELS.iter().enumerate() {
            let (sym, conf) = classify_vowel(v.f1, v.f2);
            assert_eq!(sym, i, "exact formants should classify correctly for vowel {i}");
            assert!(conf > 0.0, "confidence should be positive for vowel {i}");
        }
    }

    #[test]
    fn test_symbols_for_bytes() {
        assert_eq!(symbols_for_bytes(1), 2);  // 8 bits → 2 symbols (8 bits capacity)
        assert_eq!(symbols_for_bytes(3), 6);  // 24 bits → 6 symbols (24 bits capacity)
        assert_eq!(symbols_for_bytes(6), 12); // 48 bits → 12 symbols (48 bits capacity)
    }
}
